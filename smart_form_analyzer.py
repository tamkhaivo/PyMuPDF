"""
Smart PDF Field Analyzer & Auto-Filler
=======================================
This script takes a fundamentally different approach from hardcoded field positions.
It **analyzes** a PDF to discover labeled form fields by detecting visual patterns:

  1. ANALYZE  — Scan each page for text spans that look like field labels (e.g. "First Name:")
               and dashed/solid underlines that mark the fillable area.
  2. CLASSIFY — Map each discovered label to a semantic field key using fuzzy matching
               so it can be paired with the right data from any JSON source.
  3. FETCH    — Mock an API call to retrieve the person record (JSON).
  4. FILL     — Overlay values onto the detected field positions and save the result.

This works on the form generated by pdf_form_fill_workflow.py, but the analysis
logic is generic enough to handle other similarly-structured PDF forms.

Requires: PyMuPDF (pymupdf)
"""

import pymupdf
import os
import json
import time
import re

OUTPUT_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "demo_output")

# Value text style
CLR_VALUE = (0.02, 0.02, 0.45)


# ═════════════════════════════════════════════════════════════════════════════
# STEP 1 — ANALYZE: Discover labeled fields in the PDF
# ═════════════════════════════════════════════════════════════════════════════

def analyze_pdf_fields(pdf_path):
    """
    Scan every page of the PDF and return a list of discovered fields.

    Detection strategy:
      • Find every text span whose content ends with ":"  → candidate label
      • For each label, search the same page's vector drawings for a horizontal
        dashed line whose y-coordinate is close to the label's baseline and
        whose x-start is to the right of the label  → the "fill zone"
      • If no dashed line is found, look for any horizontal line to the right
        within a small vertical tolerance (fallback for solid underlines).
      • Record the field with its label text, bounding box, fill-zone start,
        and page index.

    Returns:
        list[dict] — one entry per detected field, e.g.:
        {
            "label":      "First Name",
            "label_bbox": (x0, y0, x1, y1),
            "fill_x":     230.0,
            "fill_y":     114.0,
            "fill_x_end": 552.0,
            "page":       0,
        }
    """
    doc = pymupdf.open(pdf_path)
    discovered = []

    for page_idx in range(len(doc)):
        page = doc[page_idx]

        # ── Gather all horizontal lines on this page ──
        drawings = page.get_drawings()
        h_lines = []  # (x_start, x_end, y, is_dashed)
        for d in drawings:
            is_dashed = bool(d.get("dashes"))
            for item in d.get("items", []):
                if item[0] == "l":  # line
                    p1, p2 = item[1], item[2]
                    # Horizontal if y-coords are nearly equal
                    if abs(p1.y - p2.y) < 2:
                        x_start = min(p1.x, p2.x)
                        x_end = max(p1.x, p2.x)
                        # Skip very short lines (decorative)
                        if x_end - x_start > 40:
                            h_lines.append((x_start, x_end, (p1.y + p2.y) / 2, is_dashed))

        # ── Gather all text spans ──
        text_dict = page.get_text("dict")
        label_spans = []
        for block in text_dict["blocks"]:
            if "lines" not in block:
                continue
            for line in block["lines"]:
                for span in line["spans"]:
                    text = span["text"].strip()
                    if text:
                        label_spans.append({
                            "text": text,
                            "bbox": span["bbox"],  # (x0, y0, x1, y1)
                            "font": span["font"],
                            "size": span["size"],
                        })

        # ── Match labels to fill zones ──
        for span in label_spans:
            text = span["text"]

            # A label must end with ":"
            if not text.endswith(":"):
                continue

            # Skip section headers (they're large and all-caps but end with ":")
            # We only want field labels — typically size 10-12, bold font
            if span["size"] > 14:
                continue

            label_clean = text.rstrip(":").strip()
            lx0, ly0, lx1, ly1 = span["bbox"]
            label_baseline_y = ly1  # bottom of label text

            # Look for a dashed line to the right of the label, at roughly the same y
            best_line = None
            best_priority = 999  # lower = better (dashed preferred)

            for (lx_s, lx_e, ly, is_dashed) in h_lines:
                # Line must start to the right of the label
                if lx_s < lx1 - 10:
                    continue
                # Line y must be close to label baseline (within ~6 pts)
                if abs(ly - label_baseline_y) > 6:
                    continue
                priority = 0 if is_dashed else 1
                if priority < best_priority or (
                    priority == best_priority
                    and (best_line is None or lx_e - lx_s > best_line[1] - best_line[0])
                ):
                    best_line = (lx_s, lx_e, ly, is_dashed)
                    best_priority = priority

            if best_line is None:
                # No underline found — skip (this label is likely a header or footer)
                continue

            discovered.append({
                "label": label_clean,
                "label_bbox": (lx0, ly0, lx1, ly1),
                "fill_x": best_line[0] + 2,       # small left padding
                "fill_y": best_line[2] - 2,        # just above the line
                "fill_x_end": best_line[1],
                "page": page_idx,
                "line_dashed": best_line[3],
            })

    doc.close()
    return discovered


# ═════════════════════════════════════════════════════════════════════════════
# STEP 2 — CLASSIFY: Map discovered labels → semantic field keys
# ═════════════════════════════════════════════════════════════════════════════

# Mapping of known label text → canonical field key.
# Uses lowercase matching and supports multiple aliases.
LABEL_TO_KEY = {
    "first name":           "first_name",
    "middle name":          "middle_name",
    "last name":            "last_name",
    "date of birth":        "date_of_birth",
    "dob":                  "date_of_birth",
    "gender":               "gender",
    "marital status":       "marital_status",
    "nationality":          "nationality",

    "email address":        "email",
    "email":                "email",
    "phone number":         "phone",
    "phone":                "phone",
    "alternate phone":      "alt_phone",
    "alt phone":            "alt_phone",
    "street address":       "street_address",
    "address":              "street_address",
    "apt / suite":          "apt_suite",
    "apt/suite":            "apt_suite",
    "city":                 "city",
    "state":                "state",
    "zip code":             "zip_code",
    "zip":                  "zip_code",
    "country":              "country",

    "employer name":        "employer_name",
    "employer":             "employer_name",
    "job title":            "job_title",
    "department":           "department",
    "employee id":          "employee_id",
    "start date":           "start_date",
    "annual salary":        "annual_salary",
    "salary":               "annual_salary",
    "work phone":           "work_phone",
    "work email":           "work_email",

    "full name":            "emergency_name",
    "relationship":         "emergency_relationship",

    "social security number":   "ssn",
    "ssn":                      "ssn",
    "driver license #":         "drivers_license",
    "driver license":           "drivers_license",
    "dl issuing state":         "dl_state",
    "dl state":                 "dl_state",
    "passport number":          "passport_number",
    "passport":                 "passport_number",
}


def classify_fields(discovered_fields):
    """
    Assign a semantic field_key to each discovered label using fuzzy matching.
    Returns a list of dicts with an added 'field_key' entry (or None if unrecognized).
    """
    classified = []
    # Track which section we're in to disambiguate shared labels like "Phone" / "Email"
    current_section = None

    for field in discovered_fields:
        label_lower = field["label"].lower().strip()

        # Detect section from layout — section headers are the labels before field rows
        # (we already filtered them out — but we can use page context heuristics)

        # Direct lookup
        key = LABEL_TO_KEY.get(label_lower)

        # If not found, try substring matching
        if key is None:
            for known_label, known_key in LABEL_TO_KEY.items():
                if known_label in label_lower or label_lower in known_label:
                    key = known_key
                    break

        classified.append({**field, "field_key": key})

    return classified


# ═════════════════════════════════════════════════════════════════════════════
# STEP 3 — Context-Aware Disambiguation
# ═════════════════════════════════════════════════════════════════════════════

def disambiguate_fields(classified_fields, pdf_path):
    """
    Some labels like "Phone" and "Email" appear in multiple sections
    (Contact vs Employment vs Emergency). Use surrounding section headers
    in the PDF to determine context and remap keys accordingly.
    """
    doc = pymupdf.open(pdf_path)

    # Gather section headers: text spans that are bold, ~11pt, and
    # appear in the section-header band (all-caps typically)
    section_headers = []  # (page, y, title)
    for page_idx in range(len(doc)):
        page = doc[page_idx]
        text_dict = page.get_text("dict")
        for block in text_dict["blocks"]:
            if "lines" not in block:
                continue
            for line in block["lines"]:
                for span in line["spans"]:
                    text = span["text"].strip()
                    if (
                        text
                        and span["size"] >= 10
                        and span["size"] <= 12
                        and "Bold" in span["font"]
                        and text == text.upper()
                        and len(text) > 5
                        and not text.endswith(":")
                    ):
                        section_headers.append((page_idx, span["bbox"][1], text))
    doc.close()

    # For each field, find which section it belongs to
    for field in classified_fields:
        p = field["page"]
        fy = field["label_bbox"][1]

        # Find the nearest section header above this field on the same page
        best_section = None
        best_dist = 999999
        for (sp, sy, title) in section_headers:
            if sp == p and sy < fy:
                dist = fy - sy
                if dist < best_dist:
                    best_dist = dist
                    best_section = title
            elif sp < p:
                # Section on a previous page could carry over
                if best_section is None:
                    best_section = title

        field["_section"] = best_section or "UNKNOWN"

        # Remap ambiguous keys based on section
        if field["field_key"] in ("phone", "email", "emergency_name", "emergency_relationship"):
            section_lower = (best_section or "").lower()
            if "emergency" in section_lower:
                if field["field_key"] == "phone":
                    field["field_key"] = "emergency_phone"
                elif field["field_key"] == "email":
                    field["field_key"] = "emergency_email"
                elif field["field_key"] == "emergency_name":
                    pass  # already correct
            elif "employment" in section_lower:
                if field["field_key"] == "phone":
                    field["field_key"] = "work_phone"
                elif field["field_key"] == "email":
                    field["field_key"] = "work_email"

    return classified_fields


# ═════════════════════════════════════════════════════════════════════════════
# STEP 4 — FETCH: Mock API call for person data
# ═════════════════════════════════════════════════════════════════════════════

def mock_api_fetch():
    """Simulate fetching a person record from a remote database."""
    print("  ┌─ POST https://api.acme.internal/v2/persons/lookup")
    print('  │  Body: {"person_id": "P-2024-08193"}')
    time.sleep(0.4)
    print("  │  ← 200 OK  (Content-Type: application/json, 1.2 KB)")
    time.sleep(0.2)
    print("  └─ ✓ Response received")
    print()

    person = {
        "first_name":       "Alexander",
        "middle_name":      "James",
        "last_name":        "Whitfield",
        "date_of_birth":    "03/15/1988",
        "gender":           "Male",
        "marital_status":   "Married",
        "nationality":      "United States",
        "email":            "a.whitfield@email.com",
        "phone":            "(415) 555-0173",
        "alt_phone":        "(415) 555-0299",
        "street_address":   "1842 Maple Ridge Drive",
        "apt_suite":        "Suite 4B",
        "city":             "San Francisco",
        "state":            "California",
        "zip_code":         "94122",
        "country":          "United States",
        "employer_name":    "Acme Corporation",
        "job_title":        "Senior Software Engineer",
        "department":       "Platform Engineering",
        "employee_id":      "EMP-2024-08193",
        "start_date":       "01/10/2020",
        "annual_salary":    "$185,000",
        "work_phone":       "(415) 555-8000 x4421",
        "work_email":       "awhitfield@acme.com",
        "emergency_name":           "Sophia Whitfield",
        "emergency_relationship":   "Spouse",
        "emergency_phone":          "(415) 555-0174",
        "emergency_email":          "sophia.w@email.com",
        "ssn":              "***-**-6789",
        "drivers_license":  "D8834921",
        "dl_state":         "California",
        "passport_number":  "X12345678",
    }

    json_path = os.path.join(OUTPUT_DIR, "analyzer_api_response.json")
    with open(json_path, "w") as f:
        json.dump(person, f, indent=2)
    print(f"  ✓ Saved API response: {json_path}")
    print()

    return person


# ═════════════════════════════════════════════════════════════════════════════
# STEP 5 — FILL: Write values onto the PDF at detected positions
# ═════════════════════════════════════════════════════════════════════════════

def fill_detected_fields(pdf_path, classified_fields, person_data, output_path):
    """
    Open the blank form and overlay values at each detected field position.
    """
    doc = pymupdf.open(pdf_path)
    filled = 0
    skipped = []

    for field in classified_fields:
        key = field["field_key"]
        if key is None:
            skipped.append(field["label"])
            continue

        value = person_data.get(key, "")
        if not value:
            skipped.append(f"{field['label']} (no data for key '{key}')")
            continue

        page = doc[field["page"]]

        # Calculate available width and truncate if necessary
        avail_width = field["fill_x_end"] - field["fill_x"] - 4
        # Rough character width estimate at 10pt Helvetica ≈ 5.5px per char
        max_chars = int(avail_width / 5.5)
        display_value = str(value)[:max_chars]

        page.insert_text(
            (field["fill_x"], field["fill_y"]),
            display_value,
            fontsize=10,
            fontname="helv",
            color=CLR_VALUE,
        )
        filled += 1

    doc.save(output_path)
    doc.close()

    return filled, skipped


# ═════════════════════════════════════════════════════════════════════════════
# STEP 6 — VERIFY: Extract text and confirm all values appear
# ═════════════════════════════════════════════════════════════════════════════

def verify_filled_pdf(output_path, person_data):
    """Extract text from the filled PDF and check that each value is present."""
    doc = pymupdf.open(output_path)
    all_text = ""
    for pg in doc:
        all_text += pg.get_text()
    doc.close()

    verified = 0
    missing = []
    for key, value in person_data.items():
        if str(value) in all_text:
            verified += 1
        else:
            missing.append(key)

    return verified, missing


# ═════════════════════════════════════════════════════════════════════════════
# MAIN
# ═════════════════════════════════════════════════════════════════════════════

def main():
    print()
    print("╔" + "═" * 65 + "╗")
    print("║" + "  Smart PDF Field Analyzer & Auto-Filler".center(65) + "║")
    print("║" + "  Analyze → Classify → Fetch → Fill → Verify".center(65) + "║")
    print("╚" + "═" * 65 + "╝")
    print()

    blank_pdf = os.path.join(OUTPUT_DIR, "form_blank.pdf")
    if not os.path.exists(blank_pdf):
        print(f"  ✗ Blank form not found at {blank_pdf}")
        print(f"    Run pdf_form_fill_workflow.py first to generate it.")
        return

    # ── STEP 1: Analyze ──────────────────────────────────────────────────
    print("═" * 67)
    print("  STEP 1 — Analyzing PDF for labeled fields")
    print("═" * 67)

    discovered = analyze_pdf_fields(blank_pdf)
    print(f"  ✓ Discovered {len(discovered)} labeled fields across the document")
    print()
    print(f"  {'#':<4} {'Page':<6} {'Label':<28} {'Fill X':<10} {'Fill Y':<10} {'Dashed'}")
    print(f"  {'─'*4} {'─'*5} {'─'*27} {'─'*9} {'─'*9} {'─'*6}")
    for i, f in enumerate(discovered, 1):
        print(
            f"  {i:<4} {f['page']:<6} {f['label']:<28} {f['fill_x']:<10.0f} "
            f"{f['fill_y']:<10.0f} {'✓' if f['line_dashed'] else '—'}"
        )
    print()

    # ── STEP 2: Classify ─────────────────────────────────────────────────
    print("═" * 67)
    print("  STEP 2 — Classifying discovered labels → semantic field keys")
    print("═" * 67)

    classified = classify_fields(discovered)

    # ── STEP 2b: Disambiguate ────────────────────────────────────────────
    classified = disambiguate_fields(classified, blank_pdf)

    matched = sum(1 for f in classified if f["field_key"] is not None)
    unmatched = [f["label"] for f in classified if f["field_key"] is None]
    print(f"  ✓ Matched {matched}/{len(classified)} fields to semantic keys")
    if unmatched:
        print(f"  ⚠ Unmatched labels: {', '.join(unmatched)}")
    print()

    print(f"  {'Label':<28} {'→ Key':<28} {'Section'}")
    print(f"  {'─'*27} {'─'*27} {'─'*20}")
    for f in classified:
        key_display = f["field_key"] or "❌ (unknown)"
        section = f.get("_section", "?")[:20]
        print(f"  {f['label']:<28} {key_display:<28} {section}")
    print()

    # ── STEP 3: Fetch ────────────────────────────────────────────────────
    print("═" * 67)
    print("  STEP 3 — Fetching person data from mock API")
    print("═" * 67)

    person_data = mock_api_fetch()

    # ── STEP 4: Fill ─────────────────────────────────────────────────────
    print("═" * 67)
    print("  STEP 4 — Filling detected fields with API data")
    print("═" * 67)

    output_path = os.path.join(OUTPUT_DIR, "form_auto_filled.pdf")
    filled, skipped = fill_detected_fields(blank_pdf, classified, person_data, output_path)
    print(f"  ✓ Filled {filled} fields")
    if skipped:
        print(f"  ⚠ Skipped {len(skipped)}: {', '.join(skipped[:5])}")
    print(f"  ✓ Saved: {output_path}")
    print()

    # ── STEP 5: Verify ───────────────────────────────────────────────────
    print("═" * 67)
    print("  STEP 5 — Verifying filled PDF")
    print("═" * 67)

    verified, missing = verify_filled_pdf(output_path, person_data)
    print(f"  ✓ Verified {verified}/{len(person_data)} values in extracted text")
    if missing:
        print(f"  ⚠ Could not verify: {', '.join(missing)}")
    else:
        print(f"  ✓ All values confirmed present!")
    print()

    # ── Summary ──────────────────────────────────────────────────────────
    print("═" * 67)
    print("  COMPLETE")
    print("═" * 67)
    print(f"  Input PDF    : {blank_pdf}")
    print(f"  Fields found : {len(discovered)}")
    print(f"  Fields filled: {filled}")
    print(f"  Output PDF   : {output_path}")
    print()


if __name__ == "__main__":
    main()
